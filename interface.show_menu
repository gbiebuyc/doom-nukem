srced/ed_bmp_reader.c:                                            d->screen->format->format);
srced/ed_bmp_reader.c:			copy_surface_to_surface(texture_test, d->screen, (int[2]){0,0}, d);
srced/ed_conversion.c:	return ((t_vec2f){(p.x - d->pos.x) * d->scale + W / 2,
srced/ed_conversion.c:			-(p.y - d->pos.y) * d->scale + H / 2});
srced/ed_conversion.c:	return ((t_vec2f){(p.x - W / 2) / d->scale + d->pos.x,
srced/ed_conversion.c:			-(p.y - H / 2) / d->scale + d->pos.y});
srced/ed_detect_assets.c:	if (!d->interface.monster_list)
srced/ed_detect_assets.c:	lst = d->interface.monster_list;
srced/ed_detect_wall.c:	if (dist < 15 && w1 >= d->sectors[selected_sector].firstwallnum)
srced/ed_detect_wall.c:	while (++s < d->numsectors)
srced/ed_detect_wall.c:		last = d->sectors[s].firstwallnum + d->sectors[s].numwalls;
srced/ed_detect_wall.c:		w2 = d->sectors[s].firstwallnum;
srced/ed_detect_wall.c:				(t_vec2f[2]){worldtoscreen(d, d->walls[w1].point),
srced/ed_detect_wall.c:				worldtoscreen(d, d->walls[w2].point)}, &(t_vec2f){x, y}))
srced/ed_detect_wall.c:	d->hl_wallnum_draw = search_wall(d, x, y);
srced/ed_detect_wall.c:	d->hl_wallnum = search_wall(d, x, y);
srced/ed_detect_wall.c:	if (d->hl_wallnum != -1)
srced/ed_detect_wall.c:		d->hl_wall = &d->walls[d->hl_wallnum];
srced/ed_detect_wall.c:		ft_printf("[Selected wall] = %d\n", d->hl_wallnum);
srced/ed_door_toggle.c:	sect = &d->sectors[in_which_sector_is_this_wall(d, w)];
srced/ed_door_toggle.c:	wallnum = w - d->walls;
srced/ed_door_toggle.c:	return (&d->walls[nextwallnum]);
srced/ed_door_toggle.c:		if (d->walls[i].neighborsect != -1 &&
srced/ed_door_toggle.c:			same_pos(&d->walls[i], nextwall) &&
srced/ed_door_toggle.c:			same_pos(&d->walls[j], d->selectedwall))
srced/ed_door_toggle.c:			d->walls[i].is_door = d->selectedwall->is_door;
srced/ed_door_toggle.c:	if (d->selected_wall != -1 || d->hl_wallnum != -1)
srced/ed_door_toggle.c:		d->selectedwall = d->walls +
srced/ed_door_toggle.c:				((d->selected_wall != -1) ? d->selected_wall : d->hl_wallnum);
srced/ed_door_toggle.c:		if (d->selectedwall->neighborsect == -1)
srced/ed_door_toggle.c:			d->selectedwall = NULL;
srced/ed_door_toggle.c:		d->selectedwall->is_door = !d->selectedwall->is_door;
srced/ed_door_toggle.c:		neighborsect = d->sectors + d->selectedwall->neighborsect;
srced/ed_door_toggle.c:		nextwall = get_adjacent_wall(d, d->selectedwall);
srced/ed_door_toggle.c:		printf("is_door: %d\n", d->selectedwall->is_door);
srced/ed_door_toggle.c:	d->selectedwall = NULL;
srced/ed_draw.c:		if (d->interface.texture_case_select == -1 &&
srced/ed_draw.c:	j = d->sectors[sectnum].numwalls - 1;
srced/ed_draw.c:	while (i < d->sectors[sectnum].numwalls)
srced/ed_draw.c:		w[0] = &d->walls[d->sectors[sectnum].firstwallnum + i];
srced/ed_draw.c:		w[1] = &d->walls[d->sectors[sectnum].firstwallnum + j];
srced/ed_draw.c:		if (d->sectors[sectnum].firstwallnum + j == d->hl_wallnum_draw)
srced/ed_draw.c:	limit = W - (d->interface.texture_case_select != -1 ? TEXTURE_TOOLBAR
srced/ed_draw.c:	ft_memset(d->screen->pixels, 0, W * H * 4);
srced/ed_draw.c:	if (!d->interface.prompt_map_open)
srced/ed_draw.c:		while (++s < d->numsectors)
srced/ed_draw.c:		draw_assets_to_map(d, d->interface.toolbar.assets);
srced/ed_draw.c:		if (d->interface.category != -1)
srced/ed_draw.c:			draw_selection_arround_asset(d, d->interface.category_pos);
srced/ed_draw.c:		if (d->interface.selected_asset != -1)
srced/ed_draw.c:							&d->interface.selected_asset_position, 0x00ff00);
srced/ed_draw.c:	ft_printf("%d\n", d->interface.show_menu);
srced/ed_draw.c:	SDL_UpdateWindowSurface(d->win);
srced/ed_draw_assets.c:	if (!d->interface.monster_list)
srced/ed_draw_assets.c:	lst = d->interface.monster_list->begin;
srced/ed_draw_assets.c:	d->texture_to_scale = 32;
srced/ed_draw_assets.c:		if (p.x + 16 < W - (d->interface.texture_case_select != -1 ?
srced/ed_draw_assets.c:				a[lst->category].assets[lst->selected_asset], d->screen,
srced/ed_draw_assets.c:	d->texture_to_scale = -1;
srced/ed_draw_assets.c:	p = worldtoscreen(d, (t_vec2f){d->player_start.x, d->player_start.z});
srced/ed_draw_assets.c:		copy_surface_to_surface(d->interface.toolbar.player_start, d->screen,
srced/ed_editor.c:	d->sectors[sectnum].ceilheight += val;
srced/ed_editor.c:										d->sectors[sectnum].ceilheight);
srced/ed_editor.c:	d->sectors[sectnum].floorheight += val;
srced/ed_editor.c:										d->sectors[sectnum].floorheight);
srced/ed_editor.c:	if (!d->sectordrawing)
srced/ed_editor.c:	sect = &d->sectors[d->numsectors - 1];
srced/ed_editor.c:	d->numwalls--;
srced/ed_editor.c:		d->selectedwall--;
srced/ed_editor.c:		d->numwalls--;
srced/ed_editor.c:		d->numsectors--;
srced/ed_editor.c:		d->selectedwall = NULL;
srced/ed_editor.c:		d->sectordrawing = false;
srced/ed_editor.c:	while (++s < d->numsectors)
srced/ed_editor.c:		w = wall - d->walls;
srced/ed_editor.c:		if (d->sectors[s].firstwallnum > w)
srced/ed_editor.c:	d->pos.x -= (x * 0.04);
srced/ed_editor.c:	d->pos.y += (y * 0.04);
srced/ed_editor_assets_handler.c:	lst = d->interface.monster_list;
srced/ed_editor_assets_handler.c:	x = d->temp.x;
srced/ed_editor_assets_handler.c:	y = d->temp.y;
srced/ed_editor_assets_handler.c:	x = d->temp.x;
srced/ed_editor_assets_handler.c:	y = d->temp.y;
srced/ed_editor_assets_handler.c:	if (x + 1 + y * 7 > d->interface.nb_asset[d->interface.category])
srced/ed_editor_assets_handler.c:	d->interface.selected_asset = x + y * 7;
srced/ed_editor_assets_handler.c:	d->interface.select = 0;
srced/ed_editor_assets_handler.c:	x = x * 38 + d->interface.category_pos[d->interface.category].x;
srced/ed_editor_assets_handler.c:	y = y * 36 + d->interface.category_pos[d->interface.category].y;
srced/ed_editor_assets_handler.c:	d->interface.selected_asset_position = (t_vec2f){x, y};
srced/ed_editor_assets_handler.c:	d->interface.selected_asset_cat = d->interface.category;
srced/ed_editor_assets_handler.c:	s = &d->sectors[sectornum];
srced/ed_editor_assets_handler.c:	if (d->interface.selected_asset_cat == 3)
srced/ed_editor_assets_handler.c:		d->player_start = (t_vec3f){p.x, s->floorheight + 0.5, p.y};
srced/ed_editor_assets_handler.c:		d->startsectnum = d->selected_sector;
srced/ed_editor_assets_handler.c:	else if (d->interface.selected_asset_cat == 1)
srced/ed_editor_assets_handler.c:		add_monster_to_list(d, &p, sectornum, &d->interface);
srced/ed_editor_assets_handler.c:	d->interface.selected_asset_cat = -1;
srced/ed_editor_assets_handler.c:	d->interface.selected_asset = -1;
srced/ed_editor_assets_handler.c:	d->interface.select = 1;
srced/ed_editor_functions.c:	while (++s < d->numsectors && w[0]->neighborsect == -1)
srced/ed_editor_functions.c:			k = d->sectors[s].numwalls - 1;
srced/ed_editor_functions.c:			while (l < d->sectors[s].numwalls)
srced/ed_editor_functions.c:				w[2] = &d->walls[d->sectors[s].firstwallnum + k];
srced/ed_editor_functions.c:				w[3] = &d->walls[d->sectors[s].firstwallnum + l];
srced/ed_editor_functions.c:	npoints = d->sectors[sectnum].numwalls;
srced/ed_editor_functions.c:		w[0] = &d->walls[d->sectors[sectnum].firstwallnum + i];
srced/ed_editor_functions.c:		w[1] = &d->walls[d->sectors[sectnum].firstwallnum + j];
srced/ed_editor_sector.c:	d->sectordrawing = true;
srced/ed_editor_sector.c:	d->numsectors++;
srced/ed_editor_sector.c:	d->sectors[d->numsectors - 1].firstwallnum = d->numwalls;
srced/ed_editor_sector.c:	d->sectors[d->numsectors - 1].numwalls = 0;
srced/ed_editor_sector.c:	d->sectors[d->numsectors - 1].floorheight = 0;
srced/ed_editor_sector.c:	d->sectors[d->numsectors - 1].floorpicnum = d->default_texture;
srced/ed_editor_sector.c:	d->sectors[d->numsectors - 1].ceilheight = 1;
srced/ed_editor_sector.c:	d->sectors[d->numsectors - 1].ceilpicnum = d->default_texture;
srced/ed_editor_sector.c:	d->sectors[d->numsectors - 1].light = 1.0;
srced/ed_editor_sector.c:	d->sectors[d->numsectors - 1].blinking = false;
srced/ed_editor_sector.c:	d->sectors[d->numsectors - 1].slope = 0;
srced/ed_editor_sector.c:	d->numwalls -= sect->numwalls;
srced/ed_editor_sector.c:	while (++w < d->numwalls)
srced/ed_editor_sector.c:		d->walls[w] = d->walls[w + sect->numwalls];
srced/ed_editor_sector.c:		if (d->walls[w].neighborsect == sectnum)
srced/ed_editor_sector.c:			d->walls[w].neighborsect = -1;
srced/ed_editor_sector.c:		if (d->walls[w].neighborsect > sectnum)
srced/ed_editor_sector.c:			d->walls[w].neighborsect--;
srced/ed_editor_sector.c:	d->numsectors--;
srced/ed_editor_sector.c:	while (++s < d->numsectors)
srced/ed_editor_sector.c:		d->sectors[s] = d->sectors[s + 1];
srced/ed_editor_sector.c:		d->sectors[s].firstwallnum -= n;
srced/ed_editor_sector.c:	j = d->sectors[sectnum].numwalls - 1;
srced/ed_editor_sector.c:	while (i < d->sectors[sectnum].numwalls)
srced/ed_editor_sector.c:		w0 = d->walls[d->sectors[sectnum].firstwallnum + i].point;
srced/ed_editor_sector.c:		w1 = d->walls[d->sectors[sectnum].firstwallnum + j].point;
srced/ed_editor_sector.c:	while (++s < d->numsectors)
srced/ed_editor_wall.c:		wall = d->walls + sect->firstwallnum + i;
srced/ed_editor_wall.c:		if (same_pos(wall, d->selectedwall))
srced/ed_editor_wall.c:	sect = &d->sectors[d->numsectors - 1];
srced/ed_editor_wall.c:	wall = d->walls + sect->firstwallnum;
srced/ed_editor_wall.c:	if (sect->numwalls >= 2 && same_pos(wall, d->selectedwall))
srced/ed_editor_wall.c:		d->numwalls--;
srced/ed_editor_wall.c:		d->sectordrawing = false;
srced/ed_editor_wall.c:	d->numwalls++;
srced/ed_editor_wall.c:	d->walls[d->numwalls - 1] = (t_wall){p, d->default_texture,
srced/ed_editor_wall.c:					d->default_texture, d->default_texture, 0, -1, "", false};
srced/ed_editor_wall.c:	d->selectedwall = &d->walls[d->numwalls - 1];
srced/ed_editor_wall.c:	while (wall - d->walls < d->numwalls)
srced/ed_editor_wall.c:			d->selected_wall = wall - d->walls;
srced/ed_editor_wall.c:			d->selectedwall = wall;
srced/ed_editor_wall.c:			ft_printf("Wall [%d] selected\n", d->selectedwall - d->walls);
srced/ed_editor_wall.c:			if (d->selectedwall != NULL && d->interface.separate_sector)
srced/ed_editor_wall.c:	d->selectedwall = NULL;
srced/ed_editor_wall.c:	d->selectedwall2 = NULL;
srced/ed_editor_wall.c:	wall = d->walls;
srced/ed_editor_wall.c:	if (d->selectedwall && d->selectedwall->neighborsect != -1
srced/ed_editor_wall.c:		&& !d->interface.separate_sector)
srced/ed_editor_wall.c:		neighborsect = &d->sectors[d->selectedwall->neighborsect];
srced/ed_editor_wall.c:			wall = d->walls + neighborsect->firstwallnum + i;
srced/ed_editor_wall.c:			if (same_pos(wall, d->selectedwall))
srced/ed_editor_wall.c:				d->selectedwall2 = wall;
srced/ed_editor_wall.c:	if (!d->selectedwall)
srced/ed_editor_wall.c:		d->selected_wall = -1;
srced/ed_editor_wall.c:	if (!d->selectedwall)
srced/ed_editor_wall.c:	d->selectedwall->point = p;
srced/ed_editor_wall.c:	if (d->selectedwall2)
srced/ed_editor_wall.c:		d->selectedwall2->point = p;
srced/ed_editor_wall.c:		detect_neighbors(d, in_which_sector_is_this_wall(d, d->selectedwall));
srced/ed_event.c:		d->scale *= (d->scale < 200) ? 1.1 : 1;
srced/ed_event.c:		d->scale *= (d->scale > 10) ? 0.9 : 1;
srced/ed_event.c:	if (e->motion.state & SDL_BUTTON(SDL_BUTTON_LEFT) || d->sectordrawing)
srced/ed_event.c:		(d->interface.select) ? update_wall_pos(d) : 1;
srced/ed_event.c:		(d->interface.move) ? update_pos(d, e) : 1;
srced/ed_event.c:		(d->interface.texture_case_select < 0 || x < W - TEXTURE_TOOLBAR))
srced/ed_event.c:		d->interface.mouse_pos = (t_vec2f){x, y};
srced/ed_event.c:	if (d->interface.show_menu)
srced/ed_event.c:		d->interface.is_on_menu = check_if_mouse_on_menu(d, x, y);
srced/ed_event_function.c:	return (d->interface.show_menu &&
srced/ed_event_function.c:			e->button.x >= 6 && e->button.x < d->interface.menu->w - 6 &&
srced/ed_event_function.c:	return (d->interface.show_menu &&
srced/ed_event_function.c:			e->button.x >= 6 && e->button.x < d->interface.menu->w - 6 &&
srced/ed_event_function.c:	return (d->interface.show_menu &&
srced/ed_event_function.c:			e->button.x >= 6 && e->button.x < d->interface.menu->w - 6 &&
srced/ed_event_function.c:			e->button.y >= 62 && e->button.y < d->interface.menu->h - 6);
srced/ed_event_function.c:	x = (int)d->interface.tex_select[0].x;
srced/ed_event_function.c:	y = (int)d->interface.tex_select[0].y;
srced/ed_event_function.c:	x = (int)d->interface.tex_select[1].x;
srced/ed_event_function.c:	y = (int)d->interface.tex_select[1].y;
srced/ed_event_function.c:	x = (int)d->interface.tex_select[2].x;
srced/ed_event_function.c:	y = (int)d->interface.tex_select[2].y;
srced/ed_event_function.c:	d->interface.category = -1;
srced/ed_event_function.c:		y = d->interface.category_pos[i].y;
srced/ed_event_function.c:			d->temp.x = e->motion.x - (W - PROPERTIES_LIMIT + 8);
srced/ed_event_function.c:			d->temp.y = e->motion.y - (y + 2);
srced/ed_event_function.c:			d->temp.x = (int)(d->temp.x / 38);
srced/ed_event_function.c:			d->temp.y = (int)(d->temp.y / 36);
srced/ed_event_function.c:			return (d->interface.category = i);
srced/ed_event_keyboard.c:	else if (key == SDLK_DELETE && !d->sectordrawing &&
srced/ed_event_keyboard.c:			!delete_monster(d, d->interface.monster_list))
srced/ed_event_keyboard.c:		del_sector(d, d->selected_sector, (d->sectors + d->selected_sector));
srced/ed_event_keyboard.c:		d->grid_locking = !d->grid_locking;
srced/ed_event_keyboard.c:		d->interface.separate_sector = !d->interface.separate_sector;
srced/ed_event_keyboard.c:	else if (key == SDLK_i && d->selected_sector >= 0)
srced/ed_event_keyboard.c:		d->sectors[d->selected_sector].blinking =
srced/ed_event_keyboard.c:			!d->sectors[d->selected_sector].blinking;
srced/ed_event_keyboard.c:		/**/printf("blinking: %d\n", d->sectors[d->selected_sector].blinking);
srced/ed_event_keyboard.c:	if (d->selected_sector >= 0 &&
srced/ed_event_keyboard.c:			key == SDLK_KP_2 && d->sectors[d->selected_sector].slope > -90)
srced/ed_event_keyboard.c:		d->sectors[d->selected_sector].slope -= 2;
srced/ed_event_keyboard.c:		ft_printf("slope: %d degree\n", d->sectors[d->selected_sector].slope);
srced/ed_event_keyboard.c:	else if (d->selected_sector >= 0 &&
srced/ed_event_keyboard.c:			key == SDLK_KP_8 && d->sectors[d->selected_sector].slope < 90)
srced/ed_event_keyboard.c:		d->sectors[d->selected_sector].slope += 2;
srced/ed_event_keyboard.c:		ft_printf("slope: %d degree\n", d->sectors[d->selected_sector].slope);
srced/ed_event_keyboard.c:		d->interface.show_menu = !d->interface.show_menu;
srced/ed_event_keyboard.c:		d->interface.texture_case_select = -1;
srced/ed_event_keyboard.c:		d->interface.selected_asset = -1;
srced/ed_event_keyboard.c:		d->interface.prompt_map_open = 0;
srced/ed_event_keyboard.c:		(d->sectordrawing) ? add_wall(d) : add_sector(d);
srced/ed_event_keyboard.c:		floor_height(d, ((key == SDLK_KP_1) ? -0.1 : 0.1), d->selected_sector);
srced/ed_event_keyboard.c:		ceil_height(d, ((key == SDLK_KP_7) ? -0.1 : 0.1), d->selected_sector);
srced/ed_event_keyboard.c:	else if (key == SDLK_b && d->selected_sector >= 0)
srced/ed_event_keyboard.c:		d->sectors[d->selected_sector].outdoor =
srced/ed_event_keyboard.c:			!d->sectors[d->selected_sector].outdoor;
srced/ed_event_keyboard.c:	else if (d->selected_sector >= 0 &&
srced/ed_event_keyboard.c:			((key == SDLK_KP_4 && d->sectors[d->selected_sector].light > 0) ||
srced/ed_event_keyboard.c:			(key == SDLK_KP_6 && d->sectors[d->selected_sector].light < 1)))
srced/ed_event_keyboard.c:		d->sectors[d->selected_sector].light += (key == SDLK_KP_4) ? -0.1 : 0.1;
srced/ed_event_mouse_button.c:	if (!is_on_select_move_icon(d, x, y) && d->interface.select &&
srced/ed_event_mouse_button.c:		x < W - PROPERTIES_LIMIT && d->interface.texture_case_select < 0
srced/ed_event_mouse_button.c:		&& !d->sectordrawing)
srced/ed_event_mouse_button.c:		d->selected_sector = find_sect_under_cursor(d);
srced/ed_event_mouse_button.c:		if (d->selected_sector != -1)
srced/ed_event_mouse_button.c:			ft_printf("[Selected sector] = %d\n", d->selected_sector);
srced/ed_event_mouse_button.c:		d->hl_wall = NULL;
srced/ed_event_mouse_button.c:		if (d->selected_wall == -1)
srced/ed_event_mouse_button.c:		btn_height(d, x, y, &d->interface);
srced/ed_event_mouse_button.c:	if ((d->selected_sector >= 0 || d->selected_wall >= 0 ||
srced/ed_event_mouse_button.c:		d->hl_wallnum >= 0) && d->interface.texture_case_select != -1)
srced/ed_event_mouse_button.c:			((d->selected_wall != -1) ? d->selected_wall : d->hl_wallnum));
srced/ed_event_mouse_button.c:	if ((d->selected_sector >= 0 || d->selected_wall >= 0 ||
srced/ed_event_mouse_button.c:		(intptr_t)d->hl_wall >= 0) && d->selected_texture != -1)
srced/ed_event_mouse_button.c:		d->interface.texture_case_select = properties_texture_selection(d, e);
srced/ed_event_mouse_button.c:	if (d->interface.category != -1)
srced/ed_event_mouse_button.c:	else if (d->interface.selected_asset != -1 && x < W - PROPERTIES_LIMIT)
srced/ed_event_mouse_button.c:	if (e->button.button == SDL_BUTTON_LEFT && !d->sectordrawing)
srced/ed_event_mouse_button.c:			d->interface.texture_case_select < 0)
srced/ed_event_mouse_button.c:			d->selectedwall = NULL;
srced/ed_event_mouse_button.c:			d->selectedwall2 = NULL;
srced/ed_event_mouse_button.c:		d->interface.select = (d->interface.move) ? 0 : 1;
srced/ed_event_mouse_button.c:		d->interface.btn_right_pressed = 0;
srced/ed_event_mouse_button.c:	if (d->interface.prompt_map_open)
srced/ed_event_mouse_button.c:		d->open_map_path = get_map_to_open(d, e);
srced/ed_event_mouse_button.c:		if (d->open_map_path) // save confirmation before leave
srced/ed_event_mouse_button.c:		d->interface.map_list = get_map_list(d);
srced/ed_event_mouse_button.c:		d->interface.prompt_map_open = 1;
srced/ed_event_mouse_button.c:	d->interface.show_menu = 0;
srced/ed_event_mouse_button.c:	if (e->button.button == SDL_BUTTON_LEFT && !d->interface.prompt_map_open)
srced/ed_event_mouse_button.c:	if (e->button.button == SDL_BUTTON_RIGHT && !d->interface.prompt_map_open)
srced/ed_event_mouse_button.c:		d->interface.select = 0;
srced/ed_event_mouse_button.c:		d->interface.btn_right_pressed = 1;
srced/ed_event_mouse_button.c:		d->interface.selected_asset = -1;
srced/ed_fix_data_to_save.c:	d->nb_used_texture = 0;
srced/ed_fix_data_to_save.c:	tmp = d->texture_list->begin;
srced/ed_fix_data_to_save.c:	tmp = d->texture_list->begin;
srced/ed_fix_data_to_save.c:		while (++j < d->numsectors)
srced/ed_fix_data_to_save.c:		while (++j < d->numwalls)
srced/ed_fix_data_to_save.c:	if (!d->texture_list)
srced/ed_fix_data_to_save.c:	tmp = d->texture_list->begin;
srced/ed_fix_data_to_save.c:		while (++j < d->numsectors && tmp->used != 1)
srced/ed_fix_data_to_save.c:				d->nb_used_texture +=
srced/ed_fix_data_to_save.c:		while (++j < d->numwalls && tmp->used != 1)
srced/ed_fix_data_to_save.c:				d->nb_used_texture +=
srced/ed_fix_data_to_save.c:		d->assets_data[i].used = 0;
srced/ed_fix_data_to_save.c:	if (!d->assets_data[0].file[0] || !d->interface.monster_list)
srced/ed_fix_data_to_save.c:	lst = d->interface.monster_list->begin;
srced/ed_fix_data_to_save.c:			if (ft_strequ(lst->name, d->assets_data[i].name))
srced/ed_fix_data_to_save.c:				d->assets_data[i].used = 1;
srced/ed_fix_data_to_save.c:/*	d->nb_monster_type = 0;
srced/ed_fix_data_to_save.c:	i = d->interface.nb_asset[0];
srced/ed_fix_data_to_save.c:	while (i < d->interface.nb_asset[0])
srced/ed_fix_data_to_save.c:		d->nb_monster_type++;*/
srced/ed_font.c:			if (d->font[(int)c][j / f->scale] & (1 << i / f->scale))
srced/ed_get_animation_files.c:	d->nb_anim_tmp = nb;
srced/ed_get_animation_files.c:	d->nb_orientation_tnp = get_nb_orientation(sort(list, nb), nb);
srced/ed_get_monster_files.c:	if (!(anim = (SDL_Surface**)malloc(sizeof(SDL_Surface*) * d->nb_anim_tmp)))
srced/ed_get_monster_files.c:	while (++i < d->nb_anim_tmp)
srced/ed_get_monster_files.c:			(mt->nb_walk_anim = d->nb_anim_tmp) < 0 ||
srced/ed_get_monster_files.c:			(mt->nb_walk_orientation = d->nb_orientation_tnp) < 0)
srced/ed_get_monster_files.c:			(mt->nb_attack_anim = d->nb_anim_tmp) < 0 ||
srced/ed_get_monster_files.c:			(mt->nb_attack_orientation = d->nb_orientation_tnp) < 0)
srced/ed_get_monster_files.c:			(mt->nb_death_anim = d->nb_anim_tmp) < 0)
srced/ed_get_monster_files.c:		name = d->assets_data[d->interface.nb_asset[0] + i].name;
srced/ed_get_monster_files.c:			if (browse_directory(d, de, folder, &d->texture_monster[i]))
srced/ed_init_assets.c:	d->assets_data[index].used = 0;
srced/ed_init_assets.c:			d->assets_data[index].file[i] = path[i];
srced/ed_init_assets.c:			d->assets_data[index].file[i] =
srced/ed_init_assets.c:		d->assets_data[index].name[i] =
srced/ed_init_assets.c:			d->interface.nb_asset[n] = i;
srced/ed_init_editor.c:		while (++j < d->interface.nb_asset[m])
srced/ed_init_editor.c:			file = d->assets_data[i].file;
srced/ed_init_editor.c:	if (!(tb->player_start = SDL_LoadBMP(d->assets_data[i].file)))
srced/ed_init_editor.c:		return (ft_printf("Loading failed : %s\n", d->assets_data[i].file));
srced/ed_init_editor.c:	if (!(d->texture_monster = (t_monsters_texture*)malloc(
srced/ed_init_editor.c:		sizeof(t_monsters_texture) * d->interface.nb_asset[1])))
srced/ed_init_editor.c:	if (get_monsters_files(d, PATH_MONSTERS, d->interface.nb_asset[1]))
srced/ed_init_editor.c:	if (!(d->interface.menu = SDL_LoadBMP("./Menu/testmenu.bmp")))
srced/ed_init_editor.c:	if (init_toolbar(&d->interface.toolbar) ||
srced/ed_init_editor.c:		init_assets(d, &d->interface.toolbar))
srced/ed_init_editor.c:	if (!(d->win = SDL_CreateWindow("editor", SDL_WINDOWPOS_CENTERED,
srced/ed_init_editor.c:	if (!(d->screen = SDL_GetWindowSurface(d->win)))
srced/ed_init_structures.c:	d->player_start = (t_vec3f){0, 0.2, 0};
srced/ed_init_structures.c:	d->interface.show_menu = 0;
srced/ed_init_structures.c:	d->interface.select = 1;
srced/ed_init_structures.c:	d->interface.move = 0;
srced/ed_init_structures.c:	d->texture_to_scale = -1;
srced/ed_init_structures.c:	d->interface.texture_case_select = -1;
srced/ed_init_structures.c:	d->interface.category = -1;
srced/ed_init_structures.c:	d->interface.selected_asset = -1;
srced/ed_init_structures.c:	d->interface.separate_sector = 0;
srced/ed_init_structures.c:	d->interface.monster_list = NULL;
srced/ed_init_structures.c:	d->interface.map_list = NULL;
srced/ed_init_structures.c:	d->interface.prompt_map_open = 0;
srced/ed_init_structures.c:	d->startsectnum = 0;
srced/ed_init_structures.c:	dt = d->default_texture;
srced/ed_init_structures.c:	d->sectors[0] = (t_sector){0, 4, 0, 1, dt, dt,
srced/ed_init_structures.c:	d->walls[0] = (t_wall){(t_vec2f){-4, 4}, dt, dt, dt, 0, -1, "", false};
srced/ed_init_structures.c:	d->walls[1] = (t_wall){(t_vec2f){4, 4}, dt, dt, dt, 0, -1, "", false};
srced/ed_init_structures.c:	d->walls[2] = (t_wall){(t_vec2f){4, -4}, dt, dt, dt, 0, -1, "", false};
srced/ed_init_structures.c:	d->walls[3] = (t_wall){(t_vec2f){-4, -4}, dt, dt, dt, 0, -1, "", false};
srced/ed_init_structures.c:	d->numsectors = 1;
srced/ed_init_structures.c:	d->numwalls = 4;
srced/ed_init_texture.c:	if (!(d->textures =
srced/ed_init_texture.c:			(SDL_Surface**)malloc(sizeof(SDL_Surface*) * d->nb_texture)))
srced/ed_init_texture.c:	while (i < d->nb_texture)
srced/ed_init_texture.c:		if (!(tmp = SDL_LoadBMP(d->texture_list->name)))
srced/ed_init_texture.c:			return (ft_printf("Failed to load %s.\n", d->texture_list->name));
srced/ed_init_texture.c:		if (!(d->textures[i] = SDL_ConvertSurface(tmp, d->screen->format, 0)))
srced/ed_init_texture.c:		if (d->texture_list->next)
srced/ed_init_texture.c:			d->texture_list = d->texture_list->next;
srced/ed_init_texture.c:				d->default_texture = d->nb_texture;
srced/ed_init_texture.c:			if (new_texture(de->d_name, (list) ? &list->next : &d->texture_list,
srced/ed_init_texture.c:				d->texture_list->begin = d->texture_list;
srced/ed_init_texture.c:			list = (!list) ? d->texture_list : list->next;
srced/ed_init_texture.c:			d->nb_texture++;
srced/ed_init_texture.c:	d->texture_list = NULL;
srced/ed_init_texture.c:	d->nb_texture = 0;
srced/ed_interface.c:	y = d->interface.toolbar.properties[4]->h + 13;
srced/ed_interface.c:	d->interface.category_pos[0] = (t_vec2f){x - 1, y - 1};
srced/ed_interface.c:	y = H * 0.15 + d->interface.toolbar.properties[5]->h + 13;
srced/ed_interface.c:	d->interface.category_pos[1] = (t_vec2f){x, y};
srced/ed_interface.c:	d->interface.category_pos[2] = (t_vec2f){x, y + (H * 0.15)};
srced/ed_interface.c:	y = H * 0.40 + d->interface.toolbar.properties[7]->h + 20;
srced/ed_interface.c:	d->interface.category_pos[3] = (t_vec2f){x, y};
srced/ed_interface.c:		y = d->interface.category_pos[m].y;
srced/ed_interface.c:		d->texture_to_scale = 32;
srced/ed_interface.c:		while (++j < d->interface.nb_asset[m])
srced/ed_interface.c:			copy_surface_to_surface(a[m].assets[j], d->screen,
srced/ed_interface.c:		d->texture_to_scale = -1;
srced/ed_interface.c:	y = d->interface.category_pos[3].y;
srced/ed_interface.c:	copy_surface_to_surface(d->interface.toolbar.player_start, d->screen,
srced/ed_interface.c:	copy_surface_to_surface(prop[4], d->screen, (int[2]){x, y}, d);
srced/ed_interface.c:	copy_surface_to_surface(prop[5], d->screen, (int[2]){x, y + 5}, d);
srced/ed_interface.c:	copy_surface_to_surface(prop[6], d->screen, (int[2]){x, y + 5}, d);
srced/ed_interface.c:	copy_surface_to_surface(prop[7], d->screen, (int[2]){x, y + 5}, d);
srced/ed_interface.c:	print_assets(d, d->interface.toolbar.assets);
srced/ed_interface.c:	while (i < d->nb_texture)
srced/ed_interface.c:		if (d->textures[i]->w > 64 || d->textures[i]->h > 64)
srced/ed_interface.c:			d->texture_to_scale = 64;
srced/ed_interface.c:		copy_surface_to_surface(d->textures[i], d->screen, (int[2]){x, y}, d);
srced/ed_interface.c:		d->texture_to_scale = -1;
srced/ed_interface.c:**	can get the height using : d->interface.toolbar.select[0]->h
srced/ed_interface.c:	if (d->interface.show_menu)
srced/ed_interface.c:		copy_surface_to_surface(d->interface.menu, d->screen, (int[2]){0, 0},
srced/ed_interface.c:	i = (!d->interface.select) ? 0 : 1;
srced/ed_interface.c:	copy_surface_to_surface(d->interface.toolbar.select[i], d->screen,
srced/ed_interface.c:	i = (!d->interface.move) ? 0 : 1;
srced/ed_interface.c:	copy_surface_to_surface(d->interface.toolbar.move[i], d->screen,
srced/ed_interface.c:	if (d->interface.texture_case_select != -1)
srced/ed_interface.c:	print_properties(d, d->interface.toolbar.properties);
srced/ed_interface.c:	print_assets_toolbar(d, d->interface.toolbar.properties);
srced/ed_interface_functions.c:	if (!d->grid_locking)
srced/ed_interface_functions.c:	if (!d->interface.btn_right_pressed)
srced/ed_interface_functions.c:			d->interface.select = 1;
srced/ed_interface_functions.c:			d->interface.move = 0;
srced/ed_interface_functions.c:			d->interface.select = 0;
srced/ed_interface_functions.c:			d->interface.move = 1;
srced/ed_interface_functions.c:	if (d->interface.show_menu)
srced/ed_interface_functions.c:		if (x >= 6 && x < d->interface.menu->w - 6)
srced/ed_interface_functions.c:			floor_height(d, -0.1, d->selected_sector);
srced/ed_interface_functions.c:			floor_height(d, 0.1, d->selected_sector);
srced/ed_interface_functions.c:			ceil_height(d, -0.1, d->selected_sector);
srced/ed_interface_functions.c:			ceil_height(d, 0.1, d->selected_sector);
srced/ed_interface_functions.c:	endx = d->interface.cbox_door_p.x;
srced/ed_interface_functions.c:	endy = d->interface.cbox_door_p.y;
srced/ed_interface_functions.c:	endx = d->interface.cbox_skybox_p.x;
srced/ed_interface_functions.c:	endy = d->interface.cbox_skybox_p.y;
srced/ed_interface_functions.c:		d->sectors[d->selected_sector].outdoor =
srced/ed_interface_functions.c:			!d->sectors[d->selected_sector].outdoor;
srced/ed_interface_map_list.c:	tmp = d->interface.map_list;
srced/ed_interface_map_list.c:	while (d->interface.map_list)
srced/ed_interface_map_list.c:		tmp = d->interface.map_list->next;
srced/ed_interface_map_list.c:		free(d->interface.map_list->filename);
srced/ed_interface_map_list.c:		free(d->interface.map_list);
srced/ed_interface_map_list.c:		d->interface.map_list = tmp;
srced/ed_interface_map_list.c:	d->interface.map_list = NULL;
srced/ed_interface_map_list.c:		d->interface.prompt_map_open = 0;
srced/ed_interface_map_list.c:			if (!new_map_file((!d->interface.map_list) ? &d->interface.map_list
srced/ed_interface_map_list.c:							: &d->interface.map_list->next, de->d_name))
srced/ed_interface_map_list.c:			begin = (!begin) ? d->interface.map_list : begin;
srced/ed_interface_map_list.c:			if (d->interface.map_list->next)
srced/ed_interface_map_list.c:				d->interface.map_list = d->interface.map_list->next;
srced/ed_interface_properties.c:	v = d->temp;
srced/ed_interface_properties.c:	if (v.x + 1 + v.y * 7 > d->interface.nb_asset[d->interface.category])
srced/ed_interface_properties.c:	v.x = (v.x * 38) + category_pos[d->interface.category].x;
srced/ed_interface_properties.c:	v.y = (v.y * 36) + category_pos[d->interface.category].y;
srced/ed_interface_properties.c:	show_preview(d, d->interface.toolbar.assets);
srced/ed_interface_properties.c:**	prop = d->interface.toolbar.properties
srced/ed_interface_properties.c:	d->interface.btn_floor_height_pos = (t_vec2f){x, y};
srced/ed_interface_properties.c:	copy_surface_to_surface(prop[8], d->screen, (int[2]){x, y}, d);
srced/ed_interface_properties.c:	copy_surface_to_surface(prop[9], d->screen, (int[2]){x + 32, y}, d);
srced/ed_interface_properties.c:	d->interface.btn_ceil_height_pos = (t_vec2f){x, y};
srced/ed_interface_properties.c:	copy_surface_to_surface(prop[8], d->screen, (int[2]){x, y}, d);
srced/ed_interface_properties.c:	copy_surface_to_surface(prop[9], d->screen, (int[2]){x + 32, y}, d);
srced/ed_interface_properties.c:	y = d->interface.tex_select[1].y + 110;
srced/ed_interface_properties.c:	copy_surface_to_surface(prop[10], d->screen, (int[2]){x, y - 30}, d);
srced/ed_interface_properties.c:	copy_surface_to_surface(prop[11], d->screen, (int[2]){x, y}, d);
srced/ed_interface_properties.c:	d->interface.cbox_skybox_p = (t_vec2f){d->interface.tex_select[1].x - 30,
srced/ed_interface_properties.c:	copy_surface_to_surface(((d->selected_sector != -1 &&
srced/ed_interface_properties.c:		d->sectors[d->selected_sector].outdoor) ? prop[14] : prop[13]),
srced/ed_interface_properties.c:			d->screen, (int[2]){d->interface.cbox_skybox_p.x, y}, d);
srced/ed_interface_properties.c:	y = d->interface.tex_select[2].y + 84;
srced/ed_interface_properties.c:	copy_surface_to_surface(prop[12], d->screen, (int[2]){x, y}, d);
srced/ed_interface_properties.c:	d->interface.cbox_door_p = (t_vec2f){d->interface.tex_select[2].x, y};
srced/ed_interface_properties.c:	copy_surface_to_surface((((d->selectedwall && d->selectedwall->is_door) ||
srced/ed_interface_properties.c:		(d->hl_wall && d->hl_wall->is_door)) ? prop[14] : prop[13]), d->screen,
srced/ed_interface_properties.c:								(int[2]){d->interface.tex_select[2].x, y}, d);
srced/ed_interface_properties.c:	d->interface.tex_select[2] = (t_vec2f){x, y + (prop[3]->h * 0.5)};
srced/ed_interface_properties.c:	d->interface.tex_select[1] = (t_vec2f){x, y - 33};
srced/ed_interface_properties.c:	y = d->interface.tex_select[1].y - prop[1]->h * 0.5 - 16;
srced/ed_interface_properties.c:	d->interface.tex_select[0] = (t_vec2f){x, y};
srced/ed_interface_properties.c:	copy_surface_to_surface(properties[0], d->screen, (int[2]){x, y}, d);
srced/ed_interface_properties.c:	copy_surface_to_surface(properties[1], d->screen, (int[2]){x, y + 5}, d);
srced/ed_interface_properties.c:	copy_surface_to_surface(properties[2], d->screen, (int[2]){x, y}, d);
srced/ed_interface_properties.c:	copy_surface_to_surface(properties[3], d->screen, (int[2]){x, y + 32}, d);
srced/ed_interface_properties.c:	fill_texture_selection(d, &d->interface, ((d->selected_wall == -1 &&
srced/ed_interface_properties.c:				d->hl_wall) ? d->hl_wallnum : d->selected_wall));
srced/ed_interface_properties.c:	draw_plus_minus_btn_n_checkbox(d, d->interface.toolbar.properties, 0, 0);
srced/ed_interface_properties2.c:	if (d->numwalls <= 0 && d->numsectors <= 0)
srced/ed_interface_properties2.c:	d->texture_to_scale = 64;
srced/ed_interface_properties2.c:	if (d->selected_wall != -1 || d->hl_wall)
srced/ed_interface_properties2.c:		tex_n = d->walls[wallnum].middlepicnum;
srced/ed_interface_properties2.c:		copy_surface_to_surface(d->textures[tex_n], d->screen,
srced/ed_interface_properties2.c:	if (d->selected_sector != -1)
srced/ed_interface_properties2.c:		tex_n = d->sectors[d->selected_sector].ceilpicnum;
srced/ed_interface_properties2.c:		copy_surface_to_surface(d->textures[tex_n], d->screen,
srced/ed_interface_properties2.c:		tex_n = d->sectors[d->selected_sector].floorpicnum;
srced/ed_interface_properties2.c:		copy_surface_to_surface(d->textures[tex_n], d->screen,
srced/ed_interface_properties2.c:	d->texture_to_scale = -1;
srced/ed_interface_properties2.c:	n = d->temp.x + d->temp.y * 7;
srced/ed_interface_properties2.c:	if (d->interface.category < 3)
srced/ed_interface_properties2.c:		x = d->interface.mouse_pos.x + 10;
srced/ed_interface_properties2.c:		y = d->interface.mouse_pos.y + 10;
srced/ed_interface_properties2.c:		copy_surface_to_surface(a[d->interface.category].assets[n], d->screen,
srced/ed_interface_properties2.c:	px = d->interface.cbox_skybox_p.x;
srced/ed_interface_properties2.c:	py = d->interface.tex_select[1].y + 80;
srced/ed_interface_properties2.c:	if (d->selected_sector == -1)
srced/ed_interface_properties2.c:	limit = d->sectors[d->selected_sector].light * 100;
srced/ed_monster_list_manager.c:	d->interface.monster_list = lst;
srced/ed_monster_list_manager.c:				d->interface.monster_list = NULL;
srced/ed_monster_list_manager.c:			d->nbmonsters--;
srced/ed_monster_list_manager.c:	selected_asset = d->interface.selected_asset;
srced/ed_monster_list_manager.c:	name = d->assets_data[d->interface.nb_asset[0] + selected_asset].name;
srced/ed_monster_list_manager.c:	if (!d->interface.monster_list)
srced/ed_monster_list_manager.c:		i->monster_list->begin = d->interface.monster_list;
srced/ed_monster_list_manager.c:		i->monster_list->category = d->interface.selected_asset_cat;
srced/ed_monster_list_manager.c:		i->monster_list->next->begin = d->interface.monster_list->begin;
srced/ed_monster_list_manager.c:		i->monster_list->next->category = d->interface.selected_asset_cat;
srced/ed_monster_list_manager.c:		i->monster_list = d->interface.monster_list->next;
srced/ed_monster_list_manager.c:	d->nbmonsters++;
srced/ed_pixel.c:		((uint32_t*)d->screen->pixels)[x + y * W] = color;
srced/ed_read_map.c:	if (read(f, &d->nbmonsters, sizeof(uint16_t)) < 0)
srced/ed_read_map.c:	if (d->nbmonsters > 0)
srced/ed_read_map.c:		if (!(d->monsters = (t_monster*)malloc(sizeof(t_monster) *
srced/ed_read_map.c:														d->nbmonsters)))
srced/ed_read_map.c:		while (++i < d->nbmonsters)
srced/ed_read_map.c:			 if (read(f, &d->monsters[i], sizeof(t_monster)) < 0)
srced/ed_read_map.c:	if (read(f, &d->numsectors, sizeof(int16_t)) < 0)
srced/ed_read_map.c:	while (++i < d->numsectors)
srced/ed_read_map.c:		if (read(f, &d->sectors[i], sizeof(t_sector)) < 0 ||
srced/ed_read_map.c:			read(f, d->sectors[i].floor_texture_name, 100) < 0 ||
srced/ed_read_map.c:			read(f, d->sectors[i].ceil_texture_name, 100) < 0)
srced/ed_read_map.c:	if (read(f, &d->numwalls, sizeof(int16_t)) < 0)
srced/ed_read_map.c:	while (++i < d->numwalls)
srced/ed_read_map.c:		if (read(f, &d->walls[i], sizeof(t_wall)) < 0 ||
srced/ed_read_map.c:			read(f, d->walls[i].texture_name, 100) < 0)
srced/ed_read_map.c:		read(f, &d->player_start, sizeof(t_vec3f)) < 0 ||
srced/ed_read_map.c:		read(f, &d->startsectnum, sizeof(int16_t)) < 0)
srced/ed_save_assets.c:	if (!d->monsters)
srced/ed_save_assets.c:	free(d->monsters);
srced/ed_save_assets.c:	d->monsters = NULL;
srced/ed_save_assets.c:	if (d->nbmonsters <= 0)
srced/ed_save_assets.c:	if (!(d->monsters = (t_monster*)malloc(sizeof(t_monster) * d->nbmonsters)))
srced/ed_save_assets.c:	lst = d->interface.monster_list->begin;
srced/ed_save_assets.c:		d->monsters[i] = (t_monster){lst->pos, 1.0, 0.1, 0.0, lst->sectnunm, 0,
srced/ed_save_assets.c:	if (write(f, &d->nbmonsters, sizeof(uint16_t)) < 0)
srced/ed_save_assets.c:	if (d->nbmonsters > 0)
srced/ed_save_assets.c:		while (++i < d->nbmonsters)
srced/ed_save_assets.c:			if (write(f, &d->monsters[i], sizeof(t_monster)) < 0)
srced/ed_save_assets.c:	while (++i < d->interface.nb_asset[1])
srced/ed_save_file.c:	tmp = d->texture_list->begin;
srced/ed_save_file.c:	while (++i < d->nb_texture)
srced/ed_save_file.c:			if (write(f, &d->textures[i]->w, sizeof(int)) < 0 ||
srced/ed_save_file.c:				write(f, &d->textures[i]->h, sizeof(int)) < 0 ||
srced/ed_save_file.c:				write(f, d->textures[i]->pixels, 4 * (d->textures[i]->w *
srced/ed_save_file.c:													d->textures[i]->h)) < 0)
srced/ed_save_file.c:	if (write(f, &d->nb_used_texture, sizeof(int32_t)) < 0)
srced/ed_save_file.c:	tmp = d->texture_list->begin;
srced/ed_save_file.c:	if (write(f, &d->numsectors, sizeof(d->numsectors)) < 0)
srced/ed_save_file.c:	while (++i < d->numsectors)
srced/ed_save_file.c:		if (write(f, &d->sectors[i], sizeof(t_sector)) < 0 ||
srced/ed_save_file.c:			write(f, d->sectors[i].floor_texture_name, 100) < 0 ||
srced/ed_save_file.c:			write(f, d->sectors[i].ceil_texture_name, 100) < 0)
srced/ed_save_file.c:	if (write(f, &d->numwalls, sizeof(d->numwalls)) < 0)
srced/ed_save_file.c:	while (++i < d->numwalls)
srced/ed_save_file.c:		if (write(f, &d->walls[i], sizeof(t_wall)) < 0 ||
srced/ed_save_file.c:			write(f, d->walls[i].texture_name, 100) < 0)
srced/ed_save_file.c:	startpos = d->player_start;
srced/ed_save_file.c:	startsectnum = d->startsectnum;
srced/ed_save_file.c:	set_texture_used(d, d->sectors, d->walls);
srced/ed_save_file.c:	set_texture_name(d, d->sectors, d->walls);
srced/ed_save_file.c:		write_monster_texture(d, f, d->texture_monster))
srced/ed_utils.c:	menu = d->interface.is_on_menu;
srced/ed_utils.c:	while (++y < src->h && d->texture_to_scale == -1 && (x = -1))
srced/ed_utils.c:	while (++y < d->texture_to_scale && d->texture_to_scale > 0 && (x = -1))
srced/ed_utils.c:		while (++x < d->texture_to_scale)
srced/ed_utils.c:					(int)((double)x / d->texture_to_scale * src->w) +
srced/ed_utils.c:					(int)((double)y / d->texture_to_scale * src->h) * src->w];
srced/ed_utils.c:	s = &d->sectors[d->selected_sector];
srced/ed_utils.c:		d->selected_texture = x + y * 4;
srced/ed_utils.c:		if (d->selected_texture < d->nb_texture)
srced/ed_utils.c:			if (d->interface.texture_case_select == 2 && wallnum >= 0)
srced/ed_utils.c:				d->walls[wallnum].middlepicnum = d->selected_texture;
srced/ed_utils.c:			else if (d->selected_sector >= 0)
srced/ed_utils.c:				if (d->interface.texture_case_select == 1)
srced/ed_utils.c:					s->ceilpicnum = d->selected_texture;
srced/ed_utils.c:				else if (d->interface.texture_case_select == 0)
srced/ed_utils.c:					s->floorpicnum = d->selected_texture;
srced/ed_utils.c:			d->selected_texture = -1;
srced/ed_utils.c:		d->selected_texture = -2;
srced/main.c:**	while (w < d->numwalls)
srced/main.c:**		wall = d->walls + w;
srced/main.c:**		if (w == d->sectors[s].firstwallnum)
srced/main.c:**		ft_printf("numwalls : %d\n", d->sectors[s].numwalls);
srced/main.c:	ft_printf("%d\n", d->nbmonsters);
srced/main.c:	if (d->interface.monster_list)
srced/main.c:		tmp = d->interface.monster_list->begin;
srced/main.c:		ft_printf("%s\n", d->assets_data[i].file);
srced/main.c:	SDL_DestroyWindow(d->win);
